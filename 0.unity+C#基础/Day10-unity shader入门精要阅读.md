# 开始读 unity shader 入门精要

其实是刷小红书看到很多人推这本，我来试试。今天预计看一章，下午继续 unity3D 学习，晚上画素材。启动 ddlAPP 后感觉活了一些。

## unity shader 入门精要-第二章

渲染流水线的工作任务在于由一个三维场景出发、生成（或者说渲染）一张二维图像。换句话说，计算机需要从一系列的顶点数据、纹理等信息出发，把这些信息最终转换成一张人眼可以看到的图像。而这个工作通常是由 CPU 和 GPU 共同完成的

### 概念流水线

#### 1、应用阶段（Application Stage

应用主导的，因此通常由 CPU 负责  
三个主要任务：1，准备好场景数据；2 粗粒度剔除（culling）；3 设置好每个模型的渲染状态  
输出：渲染图元（rendering primitives）​  
任务细分：  
（1）把数据加载到显存中。硬盘->RAM->显存 VRAM（GPU 访问显存更快并通常不能直接访问 RAM  
（2）设置渲染状态。例如，使用哪个顶点着色器（Vertex Shader）/片元着色器（Fragment Shader）​、光源属性、材质等。  
（3）调用 Draw Call。Draw Call 就是一个命令，它的发起方是 CPU，接收方是 GPU。这个命令仅仅会指向一个需要被渲染的图元（primitives）列表，而不会再包含任何材质信息

### 以下两个概念阶段由 GPU 实现，走 GPU 流水线

![](./截图/屏幕截图%202025-07-15%20114234.png)

#### 2、几何阶段（Geometry Stage）​

几何阶段用于处理所有和我们要绘制的几何相关的事情。例如，决定需要绘制的图元是什么，怎样绘制它们，在哪里绘制它们。这一阶段通常在 GPU 上进行。  
几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中，再交给光栅器进行处理  
输出：屏幕空间的二维顶点坐标、每个顶点对应的深度值、着色等相关信息

#### 3、光栅化阶段（Rasterizer Stage）​

使用上个阶段传递的数据来产生屏幕上的像素，并渲染出最终的图像。这一阶段也是在 GPU 上运行

#### GPU 流水线

- 1、顶点着色器：输入进来的每个顶点都会调用一次顶点着色器。相互独立，GPU 并行化处理。负责坐标变换（至少有把顶点坐标从模型空间转换到齐次裁剪空间）和逐顶点光照
- 2、裁剪（Clipping）：一条线段的一个顶点在视野内，而另一个顶点不在视野内，那么在视野外部的顶点应该使用一个新的顶点来代替，这个新的顶点位于这条线段和视野边界的交点处。是硬件上的固定操作，但我们可以自定义一个裁剪操作来对这一步进行配置
- 3、 屏幕映射：把每个图元的 x 和 y 坐标转换到屏幕坐标系（Screen Coordinates）。屏幕映射得到的屏幕坐标决定了这个顶点对应屏幕上哪个像素以及距离这个像素有多远。
- 4、三角形设置 Triangle Setup：进入光栅化阶段。上一个阶段输出的都是三角网格的顶点，即我们得到的是三角网格每条边的两个端点。但如果要得到整个三角网格对像素的覆盖情况，我们就必须计算每条边上的像素坐标。为了能够计算边界像素的坐标信息，我们就需要得到三角形边界的表示方式。这样一个计算三角网格表示数据的过程就叫做三角形设置。
- 5、三角形遍历 Triangle Traversal：三角形遍历（Triangle Traversal）阶段将会检查每个像素是否被一个三角网格所覆盖。如果被覆盖的话，就会生成一个片元（fragment）​。而这样一个找到哪些像素被三角网格覆盖的过程就是三角形遍历，这个阶段也被称为扫描变换（Scan Conversion）​。  
  输出：片元序列。（一个片元包含了很多状态，它的屏幕坐标、深度信息，以及其他从几何阶段输出的顶点信息，例如法线、纹理坐标等。
- 6、片元着色器 Fragment Shader：另一个非常重要的可编程着色器阶段。这一阶段可以完成很多重要的渲染技术，其中最重要的技术之一就是纹理采样。影响单个片元，但可以访问到导数信息（gradient，或者说是 derivative）​。
- 7、逐片元操作（Per-Fragment Operations）/Output-Merger：  
  （1）决定每个片元的可见性。这涉及了很多测试工作，例如深度测试、模板测试等。  
  （2）如果一个片元通过了所有的测试，就需要把这个片元的颜色值和已经存储在颜色缓冲区中的颜色进行合并，或者说是混合。需要指明的是，逐片元操作阶段是高度可配置性的，即我们可以设置每一步的操作细节。
- 模板测试（Stencil Test：模板缓冲 Stencil Buffer 和我们经常听到的颜色缓冲、深度缓冲几乎是一类东西
- 深度测试（Depth Test）​：同样是可以高度配置。GPU 会把该片元的深度值和已经存在于深度缓冲区中的深度值进行比较  
  对于大多数 GPU 来说，它们会尽可能在执行片元着色器之前就进行这些测试。  
  测试通过后到合并，决定混合颜色缓冲区或弃用某个颜色。混合操作也是可以高度配置的。

### 术语

- OpenGL 和 DirectX 就是这些图像应用编程接口，这些接口用于渲染二维或三维图形。可以说，这些接口架起了上层应用程序和底层 GPU 的沟通桥梁。这是接口，两个接口接显卡驱动就是显卡的操作系统，再接 GPU
- HLSL、GLSL、CG 着色语言（Shading Language）。常见的着色语言有 DirectX 的 HLSL（High Level Shading Language）​、OpenGL 的 GLSL（OpenGL Shading Language）以及 NVIDIA 的 CG（C for Graphic）​。  
  GLSL 是依赖硬件，而非操作系统层级的。但这也意味着 GLSL 的编译结果将取决于硬件供应商。要知道，世界上有很多硬件供应商—NVIDIA、ATI 等，他们对 GLSL 的编译实现不尽相同，这可能会造成编译结果不一致的情况。  
  HLSL，是由微软控制着色器的编译，就算使用了不同的硬件，同一个着色器的编译结果也是一样的  
  CG，CG 则是真正意义上的跨平台。它会根据平台的不同，编译成相应的中间语言。CG 语言的跨平台性很大原因取决于与微软的合作，这也导致 CG 语言的语法和 HLSL 非常相像，CG 语言可以无缝移植成 HLSL 代码。但缺点是可能无法完全发挥出 OpenGL 的最新特性。
- Draw Call，如 OpenGL 中的 glDrawElements 命令或者 DirectX 中的 DrawIndexedPrimitive 命令，以命令 GPU 进行渲染的操作。
- CPU 和 GPU 并行工作，使用一个命令缓冲区（Command Buffer）​，包含了一个命令队列，由 CPU 向其中添加命令，而由 GPU 从中读取命令，添加和读取的过程是互相独立的。渲染速度往往快于 CPU 提交命令的速度。如果 Draw Call 的数量太多，CPU 就会把大量时间花费在提交 Draw Call 上，造成 CPU 的过载。
- 减少 Draw Call？这里仅讨论使用批处理（Batching），把很多小的 DrawCall 合并成一个大的 Draw Call，使用批处理合并的网格将会使用同一种渲染状态。需要在 CPU 的内存中合并网格，而合并的过程是需要消耗时间的，对于这些静态物体我们只需要合并一次即可。  
  （1）避免使用大量很小的网格。当不可避免地需要使用很小的网格结构时，考虑是否可以合并它们。  
  （2）避免使用过多的材质。尽量在不同的网格之间共用同一个材质。
- 固定函数的流水线（Fixed-Function Pipeline，固定管线，只给开发者提供一些配置操作，但开发者没有对流水线阶段的完全控制权。提供了一系列接口，这些接口包含了一个函数入口点（Function Entry Points）集合，这些函数入口点会匹配 GPU 上的一个特定的逻辑功能。如果读者不是为了对较旧的设备进行兼容，不建议继续使用固定管线的渲染方式。
- Shader,
  ·GPU 流水线上一些可高度编程的阶段，而由着色器编译出来的最终代码是会在 GPU 上运行的（对于固定管线的渲染来说，着色器有时等同于一些特定的渲染设置）​；  
  ·有一些特定类型的着色器，如顶点着色器、片元着色器等；  
  ·依靠着色器我们可以控制流水线中的渲染细节，例如用顶点着色器来进行顶点变换以及传递数据，用片元着色器来进行逐像素的渲染。
- Akenine-Möller T, Haines E, Hoffman N. Real-time rendering

## Unity3D 学习

继续 unity 官方的 Junior Programmer pathway，哪里不会学哪里，会的就跳了。之后想去看 C#多线程，呃我学到现在竟然还没学多线程，但是每个脚印也都是贪婪地走过来的。哎呀我的最短路径就是会绕一点吧，至少我的，呃，抗打击能力强啊。  
可能没啥能记得因为大部分都是看一眼的事。

### 迷思

- 脚本拖到谁身上谁不能闪一下吗
- 自动补全始终出不来<-解决了，有事多重启
